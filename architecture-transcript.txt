Intro
0:00
so I've been doing a lot of streaming on clean architecture in nextjs and a lot of you uh have asked me to uh send you
0:07
the GitHub repo link which um it was an open source but I made a new one and
0:13
also to recap everything that we've learned so this video is going to be that we're going to recap everything that we learned about clean architecture
0:20
and how to fit it into um nextjs and yeah uh hope you enjoy so clean
Clean Architecture 101
0:27
architecture is a software architecture created by Bob or Robert Martin back in
0:32
2012 and it's basically um a response or an attempt an attempt to
0:40
integrate um other previous architectures into a single actionable
0:46
idea and those architectures are hexagonal architecture by Alistar cockburn uh onion architecture screaming
0:54
Etc so clean architecture basically tries to um Implement all of the ideas
1:00
and um aspects of these architectures into one single actionable idea and
1:08
Uncle Bob has uh drawn this diagram to help us understand how we can achieve
1:14
this right so he uses layers or clean architecture uses layers to structure
1:21
specific code into um different places in order to achieve the aspects and
1:28
let's actually talk about the aspects first so the aspects of these articles is that they make our apps or they make
1:34
us code our apps independent of Frameworks so what does that mean um
1:40
your business logic The Core Business logic of your application should not actually depend on Frameworks so I I
1:48
know this is a nextjs tutorial and to be honest this tutorial can be uh
1:53
implemented in any of the JavaScript meta Frameworks but yeah the idea is that we will develop our business logic
2:00
our core logic of the application the functionality in such a way that it doesn't depend on the framework all
2:06
right so in this case that is nextjs second one is that our application is testable right so if we
2:14
code everything in one single file presumably it's not really testable right you have um you're mixing UI and
2:21
database and all of these um external factors and that will prevent you from
2:28
writing unit tests for your application so clean architecture and all the other architectures that we mentioned above
2:34
they aim to make your app testable uh it's also independent of UI in the
2:40
context of nextjs that's exactly the same as independent of Frameworks right independent of database regardless if
2:47
you're uh implementing SQL server or or couchdb or postgress SQL or super base or any other database tool
2:56
out there the business logic does not depend on it any that achieves this through um so-called repository pattern
3:03
that we're going to take a look at it later but basically the logic does not
3:09
implement the database to save stuff it just asks the repository to do that and
3:15
lastly independent of any external agency it just doesn't matter right the
3:21
business rules or your applications features and functionality should not know anything
3:27
about the outside world that's basically what these architectures want us to
3:32
achieve and that's why it uses layers to separate specific type of codes in order
3:38
to achieve this so this is the original diagram that Uncle Bob Drew uh it's in a
3:45
form of a dboard or a bullseye diagram and we can see the layers right the the
3:50
outermost the blue one is web UI external interfaces DB devices then we have controllers presenters and gateways
3:58
then we have use cases and then we have entities and I'm going to be honest I didn't actually understand this diagram
4:04
the first time so I I tried to I tried to redraw it right here's the original
4:11
one redrawn by me but I made a small change I made this thick line that
4:17
basically divides the outermost layer into two separate layers where we have the
4:23
infrastructure uh part right at the bottom and also the API routes web UI external interfaces anything
4:30
uh that is consuming our application at the top and the rest is the same and
4:36
looking at this I actually thought let me take it even further and redraw
4:42
it like this and this made so much sense to me
4:47
so this is clean architecture but through a different from a different
4:54
perspective so here's the Frameworks and drivers layer right this layer is as I
4:59
mentioned is going to contain or keep all of the consumers of our system right
5:06
and that is the API Handler uh that can be an OJs server as well or a server
5:12
component or server actions or AWS lambdas or even stripe web hooks Etc
5:19
anything that has a touch point to our core logic our application core logic
5:26
right and then we have the interface adapters the controllers and presenters that's how that layer is named then we
5:31
have the application layer or the use cases layer right here which will also hold
5:39
the infrastructure interfaces and we'll talk about that we'll have the at the bottom we have the entities which are
5:46
the models right the link collection relation user too list whatever your
5:52
application is building errors because we want to have custom errors and we'll talk about that as well Etc and then we
5:59
also have the infrastructure layer at the top and in the infrastructure layer we want to isolate repositories and
6:06
services why because they always rely on some Frameworks and and tools like for
6:12
example repositories rely on specific databases right we might be using postgress or there might be a redish
6:19
database Etc so because we don't want our core logic to depend on those
6:25
Technologies we need to isolate all of that functionality into its own layer and use them or consume those
6:32
repositories and services through di because if we consume them directly the
6:38
dependency is going to be like this that means the application layer depends on the infrastructure and we don't want
6:45
that we want this Arrow to face the other way so that the infrastructure depends on the application but the
6:52
application uses things from the infrastructure through thei we'll get into more detail but as you see and you
6:59
you might have noticed it by now clean architecture describes a dependency
7:06
hierarchy it's basically telling you how to structure your code in such a way
7:11
that the dependencies do not fall on either Frameworks or infrastructure stuff like
7:18
databases Services email clients Etc so to democ clean architecture in nextjs I
App Demo
7:25
actually built a new smaller nextjs application it's basically a to-do application that implements
7:31
authentication there's a sign up there's sign in let me let me log in and yeah we have
7:39
to do explain clean architecture make UI more
7:45
responsive and that's a Todo because as you can see there is a bit of
7:50
lag but we don't really care about the UI in this project so I'm going to post
7:56
a link to the deployed version and also to the Hub uh but yeah let's this is the
8:02
app let's get into it okay there's our project and let me hide the camera for a little bit um this is the
Project Structure
8:10
project inside of the app directory we keep everything next CH related right these are the
8:17
authentication screens some UI components right here this is shad CN
8:23
other components Pages layouts and also actions so app is everything nextjs
8:30
related that means it's everything Frameworks and drivers right this is up
8:36
then we have the Dei folder which is everything dependency injection we're going to talk about that later we have
8:43
drizzle where we set up the drizzle configuration we have source which keeps
8:48
our actual application the core application here and the folders represent the layers so for example
8:54
here's the application layer and inside we have the repositories services and use cases so application layer is this
9:02
one and it held the use cases and also the infrastructure interfaces and those
9:08
are the repositories and services so if you see we have typescript files todd.
9:15
repository. interface. TS this basically holds the interface for the repository
9:22
and it tells the actual implementation which methods we wanted to implement okay then we have the entities
9:29
layer right here and we have the errors and models again entities is at the
9:35
bottom right here models and errors and here's the for example to do model I'm
9:40
using Zod because models by definition also
9:46
handle validation so if this wasn't JavaScript we would have needed to create classes but because this is
9:53
Javascript we can get away with just using a Zod schema and then export the type based on the schema and that is
10:01
enough in our case we're going to explain every layer in more detail as we go through a a specific operation like
10:07
create too but so far yeah we have entities infrastructure is here and these are the
10:14
implementations of the interfaces that we saw here of these
10:19
interfaces we have their implementations here for example we export a class that
10:25
pulls in the interface from the application layer and then then just implements it cool there's also a mock
10:33
version of the same repository it basically uses in memory we'll talk about this when we get
10:39
to testing and that was the infrastructure layer and then we have the interface adapters which is just
10:45
controllers so for example controllers are like create to-do controller get todos toggle Todo controller etc those
10:52
are the that's the source directory and then we have the tests which just
10:58
basically holds the tests inside of the unit folder I am mirroring
11:03
the exact folder structure as you as I have it in the source directory so here
11:08
is application and interface adapters I only have tests for these two layers
11:14
because that's basically the core logic of my application okay so that's the folder structure let's now go and see
Frameworks & Drivers Layer (server actions)
11:20
how the operation flows when we try to create a to-do so here's how the UI
11:27
looked like we just have an input and a button hello world we press that button
11:33
and we trigger the create to do operation flow there we go so starting
11:39
from the app inside of the actions. TS again this is the Frameworks and
11:45
drivers's layer the outermost the first layer right here and this is the touch
11:52
point where we trigger the create to do flow right server actions there's a
11:59
server action called create too and I'm using sentry with server action
12:04
instrumentation is a function from Sentry that allows me to instrument my server actions and I'm going to show you
12:10
all about it later but the server action basically gets the data from the form
12:16
data from the arguments here gets the session ID from the cookies and then it
12:22
just a awaits invokes the create Todo controller and it passes on the data and
12:28
session ID that's basically it it implements a tri catch because every layer can throw an error a custom error
12:36
and those are these errors and because we are in the Frameworks layer we want to handle these errors and return a UI
12:46
friendly message or do something so that the UI reacts accordingly the core
12:53
application logic is not aware of any UI that's why it implements custom errors
12:58
so that the consumer of the application in this case that's the server action
13:04
can handle these errors as it needs okay so there's a TR catch we invoke the
13:11
controller in the server action we handle the errors accordingly for
13:16
example if it's an input parse error we just return the message I'll talk about that as well unauthenticated error you
13:22
must be logged in to create a to do fine otherwise we capture the exception and we send it to Sentry capture exception
13:28
actually comes from the Sentry package and then we return an error an error happened while creating a to-do the
13:34
developers have been notified please try again later right
13:39
simple if no errors happen we revalidate the homepage the Slash and we just
13:46
return success true that's basically what happens in this layer once we click
13:51
that plus button and let's get into the controller now here's the create to do controller
Interface Adapters Layer (controller)
13:59
we get inside we get the input and session ID I have a start span wrapper
14:04
which basically creates uh Span in the trace so that I can later go into Sentry
14:10
and see all of the operations and how long or how much time they took I'm going to show you this later but for now
14:17
here's the controller I'm checking for a session ID controllers is the first
14:24
touch point in the core application or core logic right and they have a
14:30
responsibility to check for authentication and also for input validation if you want to create a to-do
14:38
we must provide the name for the to-do right we cannot just say here's an empty
14:43
string and create a to-do with an empty string that's not accepted right we can just say undefined that's also not
14:50
accepted so it has to be a string and it has to have some length and we also need to be logged in to create a to-do
14:56
because if we're not logged in we can't really create a to-do only logged in users can create to-dos right so the
15:03
controller right here is where that logic happens where that input
15:09
validation and also authentication checks happen because this is the first touch point of the system this is where
15:16
all sorts of Frameworks and clients are going to be using our system and because
15:21
we are designing our application in such a way that we don't care about the UI or
15:27
the framework that's why we do the check a layer into the core logic and not over
15:33
here because we want that logic to be part of our core application not do the
15:40
authentication check in the server action no so that is the reason why we have we're checking on the session ID
15:46
here if session ID does not exist or it's not passed we just throw an
15:52
unauthenticated error which comes from the models or entities layer at the
15:59
bottom here's the unauthenticated error and this is how all of the errors look
16:04
like let actually zoom in there we go so it's just an error that extends error it
16:11
accepts a message and options optional options and then it calls the super
16:17
Constructor for the error class that's all and as you can see I have authentication error unauthenticated
16:23
error and also unauthorized error okay if no session ID exists throw
16:29
unauthenticated error so whoever invokes this controller will handle that case as
16:36
they need then we use the get injection function to obtain the authentication
16:43
Service this is the DI part but we're going to talk about that later right now
16:48
it's important to know that when we use the get injection function it will
16:54
return us an instance of the I authentication ser service I stands for
17:01
interface and if you remember services and repositories had interfaces in the
17:06
applications layer and their implementations in the infrastructure layer while we are here we're not going
17:13
to be working with the implementations but we're going to be working with the interfaces so that we
17:20
don't rely or don't pull in database stuff or any third party Services stuff
17:27
so the Authentication service is of the type of the interface that means we can
17:32
do create session or invalidate session or generate user ID or validate session
17:39
this is basically what the authentication Service is capable of and we can invoke the validate session
17:45
method here we pass in the session ID which we have validated that it exists
17:50
and then we wait for the user additionally validate session will throw
17:56
an error it will throw an unauthenticated error if the session ID is invalid or if the user doesn't exist
18:02
Etc so at this line right here we know that the user is logged in and it's an
18:09
existing user and there is no issue regarding authentication that's why we
18:14
go use the input schema which is defined at the top of the file it's a Zod schema
18:21
that defines a to-do property that's a string with at least one character and
18:28
if for example Zod cannot parse the input it will return us an input parse
18:34
error and if that one exists we'll just throw uh an input parse error which again it's our error it's it's an error
18:42
that we have defined right here in this case the consumer sends us an input that
18:49
doesn't really adhere to the schema that we have defined we don't accept zero
18:55
length to do so we're going to throw an input bar error invalid data and then
19:01
we'll pass the ca here that's it if there are no errors in at this point we
19:07
know that the user exists the user is signed in and also the data is valid and
19:13
that means we can start using use cases to fulfill that operation or to execute
19:19
the operation right which is the operation of create to do the reason why we have controllers and not use the use
19:26
cases directly is because because some operations can be a bit more complex in this case we can only see one use case
19:34
and you might think let's just use the use case directly but that's big no no in some cases the operations will need
19:40
multiple use cases and this can be one as well for example we have a create to do in my application I don't have lists
19:47
but imagine if I had lists I would need to create the to uh too first and then
19:54
if a list exists I would need to find the list and add added to the list or if
20:00
the list doesn't exist I need to create the list and add it to that one right so we have more operations or more
20:07
individual operations use cases are exactly that they are individual
20:13
operations that accept prevalidated data and do only one thing they Implement
20:18
separation of concerns create to do use case only creates it to do it doesn't
20:23
add it to a list it doesn't delete it it doesn't update it it doesn't publish no
20:29
it just creates a to-do adding a to-do to a list is a different operation and therefore we need a different use case
20:36
so as you can see we need a way where we can orchestrate these use cases and that's
20:43
why we have controllers that's why we can't really use use cases directly into
20:48
our applications because the logic or the order of the use cases is part of
20:54
our core logic that's why we need to keep it inside here instead of pushing it outside
21:02
that's that's crucial so we invoke the create Todo use case right here we get
21:08
the to-do and then before returning it we actually pass it through the presenter and then we'll return whatever
21:13
the presenter Returns the presenter is defined at the top it's just simple function that takes in the to-do of the
21:20
type to-do model that we have from the models from the entities layer and we
21:26
return a plain JavaScript object that Maps out the properties you might
21:32
think this is an Overkill but check this out the reason why we have presenters is that we want the data coming outside of
21:40
our core logic which is this to be UI
21:47
friendly we don't want to leak out models
21:53
outside anything that's returned from the controllers will be just objects and
21:59
will be UI friendly for example in this case I'm just mapping out all of the properties one by one and there are no
22:06
other properties on the to-do model that I'm avoiding but if this was a user and
22:14
the user model would most likely contain a hashed password field I would not
22:19
return that we don't need the actual hashed password returned from the back
22:25
end to the client right that's dangerous we don't want on that and therefore the
22:30
presenter will take care of that the presenter will return a subset of the
22:35
properties of the model that should be sent to the client or to the browser or
22:42
to whoever consumes the application and that is for SEC the security reason or the the security reason behind
22:50
presenters but there's another one let's say we have date of Creation in the
22:55
to-do right we want to keep track when we created that to-do so when we
23:01
actually completed we want to measure how long it took us to perform that task
23:07
or to close that task close the to-do in that case we would save the to-do in the
23:13
database as a date a date with a time right a time stamp we would treat it as
23:19
a date in our application as in JavaScript date and we can return it as
23:24
a date and then format it on the front end or on in the browser but that means
23:30
we also need to ship a date Library like date FNS or momentjs in order to do that
23:35
on the browser we don't need to do that on the browser we can actually do it here we can import that library and
23:43
convert that date into the format that we want without necessarily shipping dat
23:48
FNS or momentjs or whatever we use to the browser so the when the browser receives the results through the
23:55
response the date will be a string it will not not be an actual date object and that's another reason why we need
24:03
presenters or why presenters are good because of performance reasons so we get to keep any sensitive information from
24:11
spilling outside of the backend and we can also avoid shipping some libraries
24:16
in order to format the data or the result in a specific way we can do that
24:22
here in the presenter okay so that's the controller right let's get into the user
Application Layer (use case)
24:28
case so create to-do use case now we are in the application layer the create too
24:35
use case accepts an input that contains the to-do it's a string it's not
24:40
undefined because it has already been validated and it also contains a user ID
24:47
that knows that the user is valid and it exists and it is the user that is asking
24:54
to create the to-do right so the use case does not check for those things
24:59
but the use case checks for authorization it knows the user but what
25:05
if there are different types of users right what if for example three users
25:11
are allowed to only five to-dos for some reason if that's the case we can throw
25:17
an unauthorized error from the use case that's because use cases by Nature they
25:23
are individual operations and individual operations can or cannot be performed by
25:31
every user as a type of user which is free or admin or tier one tier 2 tier
25:38
three Etc based on the type we would either allow that user to perform this
25:45
operation that the use case describes or throw an unauthorized error and let
25:51
either the controller or the framework handle it so I don't have it here but
25:57
this is where you would do that check authentication stays in the controller
26:02
but authorization is in the use case over here we're still using the get injection
26:09
function to get a hold of the to-do repository we know that the input is
26:15
validated we know that the user exists we know that the user is authorized because there are no authorization
26:21
checks so we just invoke the create to-do method of the to-do repository we
26:27
pass in data we get a to-do back which is of this type and then we just return
26:33
it okay that's all that the create to-do use case does
26:39
okay aside from being wrapped with a start span so we can see how long creating a to-do actually is when we
26:46
open Sentry more like how costly this function is okay and then we just yeah
26:52
we just return it and that's it use cases are a lot simpler because they only do one thing and one thing thing
Infrastructure Layer (repository & service)
26:58
only okay we're not going to go into the entities because yeah models and errors we've already covered them but let's get
27:04
into the infrastructure layer now so as I mentioned we we're using the
27:11
interfaces in our core application logic but through the get injection
27:17
method we actually get or interface with the implementations so if
27:23
I go to the implementations of the Todo Repository
27:29
we can see the actual repository that implements the interface but it actually uses drizzle to communicate with the
27:37
database okay so here's the to-do's repository here's the create to-do
27:43
method it takes in uh to-do insert type which is user ID to-do and complete
27:51
it again I have a start span to measure the cost of this function or to measure
27:57
how long it takes for for drizzle to put this type of data in the database I have a TR catch block I
28:04
construct my query db. insert into the to-dos table here are the values and
28:10
then return the new to-do back there's the query again I do a start span with
28:16
the DB query operation here so that I can check it out later in Sentry but this is how we trigger the query query.
28:24
execute we get packt created the newly created to do and we do some checks if
28:31
it exists we return it if not we throw a database operation error cannot create
28:37
Todo because query. execute returns an array and with this structure
28:44
it like so it might not exist so we throw database operation here but we
28:49
also have a catch block to catch any stray errors as well in this case we
28:55
want to capture those exceptions and send them to Sentry we pass the data of
29:01
the actual to-do that cannot be created and I don't have it here but this is the moment where we need to convert those
29:08
database specific errors into our entity errors into basically database operation
29:15
errors depending on what database you're using it can throw different types of Errors for example there is a lot of
29:21
difference between the errors thrown from drizzle and superbase so read the docks of the database see what it throws
29:29
and figure out how to map those types of Errors into your entity errors right
29:34
because we don't want to rethrow database specific errors because if we want to handle them that means we need
29:41
to import them we don't want to import database specific stuff outside of the
29:48
infrastructure layer that's why we need to convert all of the exceptions or errors that are being thrown from the
29:54
infrastructure layer into entities errors okay and that's basically the
29:59
function create to-do that creates the to-do and puts it into the database as
30:05
you can see we don't do any checks here we don't do input validation because
30:10
that's already being done we don't do authorization or authentication but because again that's already being done
30:17
repositories take in data they don't ask questions they put it into the database
30:23
and then they return it that's all this is like a thin layer that needs to exist
30:29
in order to separate database related stuff or for example for services any
30:34
Frameworks and sdks from the rest of our application so that when we want to test
30:40
our application we don't actually need to have a database running in order for
30:45
our test to execute and for example here's how the authentication Service looks like again same thing it's a class
30:53
that implements an interface I'm using Lucia for authentic ification in the
30:59
Constructor I am setting up Lucia and here's the validate session which basically calls the validate session
31:06
method of Luchia if there's no user throws the unauthenticated error
31:11
otherwise it uses the user's repository to get the user does a check again if everything's well it Returns the user
31:18
and the session that's how I validate the user session in my application so
31:23
it's not a database but it's still a third- party dependency it is a library
31:29
for authentication that we don't want to be weaved into the core logic of our
31:34
application and that's why we separate it into its own service simple okay
Dependency Injection
31:40
let's talk about this red line right here and how we achieve this we saw how the direction of the arrow is achieved
31:47
right infrastructure depends on the application why because here we are in
31:52
the service which is infrastructure it implements the interface
31:58
which comes from the application layer as you can see these are the do
32:04
interface files that I showed you earlier so this is how the
32:09
infrastructure depends on the application but back in the application layer we use the get injection function
32:16
to obtain the repository or the service and invoke its methods everything di
32:22
related is is being kept in the DI folder so Di and then we have the
32:27
container. TS this file creates the dependency injection container it initializes all
32:34
of the modules example the to-dos users and authentication modules I also have a
32:40
destroy container which I use in unit tests it calls the initialized container
32:45
automatically if we're not in testing environment and it exports a get injection function the takes in a symbol
32:53
takes in a string and it Returns the registered ser service or repository
32:59
with that string there's some typescript gymnastics in order to achieve type
33:04
safety fill free to copy this in your own project to keep this video shorter
33:10
I'm not going to explain what K stands for and the DI symbols and the DI return types check out the GitHub repository
33:17
and you'll see how everything is connected but basically get injection Returns the service or repository that's
33:23
registered by that name for example registered as I authentication Service
33:30
and how does it know which one is it well the application container. load is
33:36
what tells it to so let's go into the authentication module there we go the
33:41
authentication module is a new container module that initializes everything related to authentication and in our
33:48
case it's simple it's just an authentication Service so as you can see here we are branching based on the Node
33:54
environment if we are in testing we're going to register something but if we're
34:00
not in testing we're going to register something else let's start with the something else we use the bind function
34:06
that we get from the arguments to register the authentication Service the
34:11
actual implementation of the authentication Service with the interface and we pass in the symbol as
34:20
an identifier but if we're running tests we're we're going to get the mocked
34:26
authentication or or the mocked version of the service so this is how we can write unit tests without having real
34:34
databases or real Services same goes for the to-dos module but it's just going to be the
34:41
repository there is a catch though because we're using invers ify for our
34:47
dependency injection container in nextjs we cannot use the edge runtime we have
34:54
to use the node runtime that's because diversify uses reflection and the edge
35:00
run time does not implement the reflection API that means if we have uh
35:05
middleware in our application it's just not going to work in order to set up inv
35:11
verify I do have a specific video on how to set up and install inv verifying
35:16
nextjs so I'm going to drop a link of that video if you want to see how I have this setup but basically that is exactly
35:24
how using di we can hide or or abstract a way specific implementations of
35:32
databases and services behind interfaces and those interfaces can live in the
35:39
application layer okay that's that's all the layers let's actually check out the
Unit Tests
35:44
tests now so in our tests folder in the unit we have application and interface
35:50
adapters let's start with the application tests so here's the create
35:55
too. use case test.ts file this is the unit test for
36:01
the create to do use case and at the top we import reflect metadata we have to
36:07
because inv verify again check the video um in the comments below we import the
36:15
after each before each expect and it from vest because we're using Vest for our tests we bring in the destroy
36:22
container and initialize container from our D container. DS file to set it up
36:30
before and after each of the test cases and then we have a the test case itself
36:37
here's a great guide on test names it is a short three minute video by artam that
36:44
tells you how you can name your test cases better do check it out it's really cool okay so it creates to-do this is
36:52
the test case that tests whether the use case creates the to-do correctly or not
36:58
so first we await the sign in use case so we can sign in we do need to have a a
37:06
valid session if we want to create a to-do and this user is already defined in the mocked version of the
37:13
authentication Service so we don't need to register in our unit tests and then we just expect the create too use case
37:21
we pass in the to-do with valid input remember this is the use case not the
37:26
controller the controller checks for uh errors thrown by thrown because of
37:33
unauthenticated or input pars error Etc this is the use case the use case must
37:40
accept prevalidated input so we pass in valid input we pass in a valid user ID
37:47
and then we expect the promise to resolve and to return an object that
37:53
matches this we have right unit tests for our to-do we have user ID set to one because that
38:00
is the uh this users's user ID and we have completed set to false because by
38:06
default new to-dos must be must not be completed and that is the only test that
38:13
we have for the use case and if I want to run it I just run it and see that
38:20
green check mark because it's true if I change this user ID to two that's going to be wrong because the username one has
38:28
a user ID of one and not two so if I run it now we're going to see an error
38:33
expect that a type of result to match a different type of result and we can see the output better we're going to see
38:41
okay we received we expected a user ID of two but we actually received a user
38:46
ID of one and that's how we know that our unit tests actually work so there we
38:51
go that is the use case test right it only tests whether it works or not
38:58
if we go into the create too controller test we're going to see more tests first
39:04
at the top we do the same for every test we bring in the reflect metadata and after each before each and then we do
39:11
initialize container Etc but then here's the creates to do test case in this time
39:19
we're testing the controller instead of the use case we pass in valid data and a
39:26
session and we expect to return a valid object right and this works there we go
39:33
but aside from that we have a test that expects it to throw for invalid input so
39:40
we sign in and then we expect and then we invoke the controller without a to-do
39:47
with a plain object we pass in the session and this scenario should result
39:53
in an input parse error we have to make sure that errors are being thrown and
39:59
cover them with unit tests because that's how we can make sure that we are
40:04
providing an API so that whoever consumes our logic can handle or or can
40:11
receive the correct errors so it can handle them so in this scenario where
40:18
to-do is undefined we expect an input parse error if the to-do is defined but
40:24
it's zero length we also expect an input par error so if I run this test there we
40:30
go right it's correct I also have a test that expects the controller to throw an
40:36
error if we're unauthenticated right so we are invoking the to-do controller the to-do doesn't
40:43
matter in this case because we're sending undefined for the session and we expect it to reject with the
40:50
unauthenticated error exception and if I run this one again we can see that in
40:57
invoking the controller without a session will result with an unauthenticated error and that's how I
41:02
can check for all of the different scenarios that a consumer can use the
41:07
controllers I have unit tests for all of the controllers and they have multiple test
41:13
cases so if I run all of them I don't need to have a database or anything I
41:19
can just run them and sleep well at night because I know that my controllers and use cases function and behave the
41:26
way that I want them to and I'm actually using this in my GitHub pipeline so if I
41:33
go to GitHub test. yaml we're going to see that I have a test workflow that
41:39
gets triggered on every push it has a test job it checks out the repo sets up
41:45
node installs all the dependencies and it runs the test with coverage because I
41:50
want to report that coverage or upload that coverage to code COV later and this
41:56
is how that looks like if I do mpm run coverage all the tests are going to be
42:04
invoked and this coverage report will be generated as a file and that's basically
42:10
how clean architecture can help us structure our code in a way that it's very easy to test as you can see so we
42:17
don't have excuses not to write tests anymore right okay while we are on the
Sentry and Codecov
42:22
topic of code coverage and code C and Sentry uh let me tell you about Sentry
42:28
so full disclosure I do work at Sentry I'm a developer Advocate at Sentry so of
42:34
course I'm going to be biased but if you don't know what Sentry is Sentry is an application performance and error
42:40
monitoring platform that supports pretty much all Frameworks and languages out
42:45
there it is Source available which means you can also deploy it on your own
42:51
infrastructure on your own server and use it for free I'm going to go back to that place the create Tod do
42:58
controller there we go this is our controller and I'm going to talk about
43:03
this piece of code right here if you want to see how Sentry is installed in next JS check out the docs there's also
43:10
a whole bunch of videos on Sentry's YouTube channel but it's really simple so I have Sentry setup here and I'm
Tracing
43:16
using the start span to wrap the whole container and then inside of the
43:21
validate session I have a nested span that wraps the validate session in a in
43:26
a span of its own so I'm using this start span across the whole app right
43:32
and what this does is it creates a span that tells me when a certain function
43:37
gets executed and when it ends so I know how long it took for that function to
43:43
finish all of that is being sent to my Sentry account so here's the Sentry
43:49
dashboard in the performance tab right here I can scroll down and check out the
43:55
server action slre to do action this is the reason why in the app
44:03
actions I have the with server action instrumentation function and have the
44:08
whole server action wrapped because I want to instrument the server action and this is what I get so when I click into
44:15
it and go to the sampled events I'm going to get real events that were triggered on the production environment
44:22
on inverse cell and we're triggered by real users I don't keep track of the
44:28
users but it is possible because we have authentication in our application we can track the users as they trigger the
44:36
server actions but looking at the duration we can see how long each of them took here's one that's a bit longer
44:43
than the rest it took 556 milliseconds so let's check that one
44:50
out when we click into it we get the trace View and the trace view will lay
44:56
down all of the spans that we have created in our application with their timings so let me make some more room
45:03
and I'll show you the trace there we go so here's the trace hierarchy we start
45:08
with the server action / toggle too we invoke the toggle too controller we use
45:14
the get injection method to obtain the authentication Service instance and then
45:19
we trigger the validate session inside Luchia takes over and it makes two post
45:25
requests to turo because because my drizzle configuration uses turo as a
45:30
database so as you can see on the left side we have a hierarchy of our code
45:35
base if you go in step by step you'll see everything that gets executed when
45:41
we click to tole a Todo so if you're a new person joining a project just by
45:47
looking at the trace you can actually see how the operation flows so even if you're not familiar with the code base
45:54
this will give you a really good picture and it will help you with onboarding but yeah that's on the left side on the
46:00
right side we have a visual representation of those spans and let me
46:06
actually hide my camera of those spans and their timings so I'm going to make a split screen right here the main server
46:13
action toggle to do took 556 milliseconds out of those 556 536 were
46:22
spent inside of the toggle Todo controller and it does make sense because the action does do not actually do anything more than invoking the
46:30
controller and then handling the results now let's dive into the controller first we do the get injection which takes 0.7
46:38
milliseconds this is in production on verell so you can see that dependency injection isn't really an expensive
46:44
operation it's actually practically free and then after we have the injection we
46:49
get into the authentication Service and we invoke the validate session and I'm going to toggle these now inside of the
46:56
controller we have these four steps the majority of the time is spent
47:05
where here in the validate session so if you know that the toggle to do is super
47:12
slow you'll know where to look at if you were to optimize the performance of
47:17
toggle to-do you would need to look into the validate session functionality not
47:23
necessarily in the toggle to-do use case because it's not really a significant time the majority of the time is spent
47:30
here so if we toggle that and get inside we'll see two
47:36
functionalities validate session which is being done by luia and then we use
47:41
the users repository to get the user after we validate the session to check if the user is existing or not right
47:48
again if you want to optimize this this is where the majority of time is spent
47:55
not in the users's Repository can you do something about this maybe maybe not but
48:00
you know where the majority of the time is spent and then you can see how drizzle uses the turo adapter to send
48:08
post requests to turo and these two are what makes the validate session take 336
48:16
milliseconds we can't really optimize this and this is the trace view there's a whole bunch of modules like requests
Performance Modules
48:25
the requests module will give you all of the HTTP requests that your application is creating the percentage of 300s or
48:34
400s or 500s so you can see which endpoint or which requests errors out
48:40
more most frequently there's also assets which is a list of JavaScript files and
48:45
icons and images that your application loads and you get to see what is the average duration of that as well you can
48:52
see the the fav Eon in my case it's on average 1.1 second maybe I want to
49:00
optimize that but this tells me that it's taking pretty long on average so I'm going to look at this in my next
49:06
Sprint we also have something like web vitals that the client SDK measures for us and we're we're not talking about
49:12
Lighthouse web vitals we're actually talking about real user production real
49:18
world web vitals and they don't look good in my case can see that the score
49:24
is poor the signin page is pretty bad time to first bite is almost 3 seconds I
49:29
can get in I can see all the individual page loads here's a slow one and this
49:35
will take me to the trace view again but this time I get to debug how the page
49:42
load happened and why was it slow well this is the the biggest chunk here the
49:49
redirect everything else seems to be reasonable except the redirect is this
49:55
something I can fix Maybe maybe but I know that it's the redirect that's making this page load more than 3
50:02
seconds all right let's check out the errors now in the issues tab we can see a list of all the errors that our
Errors
50:08
application reported and if you remember we had the capture exception sprinkled
50:14
around the code that sends an exception to Century whenever it happens and
50:19
here's one there's an error inside of the signup server action the messages username taken if we click into it we
50:29
get to see that it happened five times it affected zero users because I'm not
50:34
tracking the users but you get to see how many users are also affected by this
50:39
error you get to see in the last 24 hours how many times the error happened
50:45
and you get to see the stack Trace so the stack Trace helps you see where the
50:50
actual error happened and you can even click into the GitHub link and it'll
50:55
take you to the ex exact line of code where the error happens and you also have all sorts of other information for
51:02
example info on the operating system the runtime the cloud resource Etc even the
51:08
device even though this is a server it gives you information on the actual
51:13
server which is pretty cool so one thing you can notice here is that these green
Codecov
51:19
lines and if you hover on them it says covered this is basically the test
51:24
coverage that I generate and uploads to code COV and because sentry integrates
51:29
with code COV we can click on this little umbrella the code COV logo here
51:35
and it'll take us to the code COV dashboard to this line again but we can
51:40
see in our whole project in our whole nextjs clean architecture project now we
51:46
actually have 100% test coverage this is what I'm talking about when I say clean
51:52
architecture makes it so easy for us to write unit tests you can see see that I
51:57
have 100% test coverage I know it's not a big up but I also didn't break a sweat
52:02
achieving 100% so that's basically code cof and that's how it integrates into Sentry to tell you if this error has
52:10
been covered by a unit test or not so yeah that's basically clean architecture
Outro
52:16
in nextjs I'm going to drop links to the GitHub report to the original post to the diagram to everything mentioned in
52:23
the comments below so make sure you check out the pin comment at the top of the list uh if you like this video of
52:31
course it goes without saying but I'm going to say it anyways hit like subscribe let me know if you want to see
52:37
more like this so I can spend my time creating more content like this and yeah
52:42
share with your friends I think clean architecture is nextjs is a pretty cool thing it's not super hard even though it
52:49
might sound a bit intimidating you know like architecture and stuff no it's actually really simple and it gives you
52:57
a lot of benefits so yeah here's how you can here's how you can reap all those benefits I hope you enjoyed watching
53:02
this and yeah I'm going to see you in the next one take care